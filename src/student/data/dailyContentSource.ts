
export interface PuzzlePair {
    id: number;
    term: string;
    match: string;
}

// FULL POOL OF 400 CONCEPTS
export const POOL_PUZZLES: PuzzlePair[] = [
    // --- Part 1: Fundamentals & Arrays (1-30) ---
    { id: 1, term: "Array", match: "Fixed-size contiguous memory collection" },
    { id: 2, term: "Index", match: "Numerical position of an element" },
    { id: 3, term: "Dynamic Array", match: "Resizables array that grows by doubling" },
    { id: 4, term: "Static Array", match: "Collection with a size fixed at compile-time" },
    { id: 5, term: "Vector", match: "Common name for dynamic arrays in C++" },
    { id: 6, term: "Matrix", match: "Two-dimensional array structure" },
    { id: 7, term: "Buffer", match: "Temporary storage area in memory" },
    { id: 8, term: "Offset", match: "Distance from the start of an array" },
    { id: 9, term: "Bounds", match: "The legal range of array indices" },
    { id: 10, term: "Traversal", match: "Visiting every element in a structure" },
    { id: 11, term: "In-place", match: "Algorithm using O(1) extra space" },
    { id: 12, term: "Stable Sort", match: "Maintains relative order of equal keys" },
    { id: 13, term: "Pointer", match: "Variable that stores a memory address" },
    { id: 14, term: "Dereference", match: "Accessing the value at a pointer address" },
    { id: 15, term: "Null", match: "Indicator of an empty or unassigned pointer" },
    { id: 16, term: "Contiguous", match: "Stored side-by-side in memory" },
    { id: 17, term: "Slicing", match: "Extracting a subset of a collection" },
    { id: 18, term: "Padding", match: "Empty bits added for memory alignment" },
    { id: 19, term: "Capacity", match: "Total space allocated for a dynamic structure" },
    { id: 20, term: "Size", match: "The number of elements currently stored" },
    { id: 21, term: "Primitive", match: "Basic data type like int or char" },
    { id: 22, term: "Reference", match: "Alias for an existing memory location" },
    { id: 23, term: "Big O", match: "Notation for worst-case time complexity" },
    { id: 24, term: "Omega", match: "Notation for best-case time complexity" },
    { id: 25, term: "Theta", match: "Notation for average-case time complexity" },
    { id: 26, term: "Space Complexity", match: "Memory required by an algorithm" },
    { id: 27, term: "Time Complexity", match: "Execution time relative to input size" },
    { id: 28, term: "Constant Time", match: "Complexity denoted as O(1)" },
    { id: 29, term: "Linear Time", match: "Complexity denoted as O(n)" },
    { id: 30, term: "Quadratic Time", match: "Complexity denoted as O(n^2)" },

    // --- Part 2: Linked Lists & Linear Logic (31-60) ---
    { id: 31, term: "Node", match: "Basic unit containing data and a pointer" },
    { id: 32, term: "Singly Linked", match: "Nodes with only a forward pointer" },
    { id: 33, term: "Doubly Linked", match: "Nodes with forward and backward pointers" },
    { id: 34, term: "Circular List", match: "Tail node points back to the head" },
    { id: 35, term: "Head", match: "The first node in a list" },
    { id: 36, term: "Tail", match: "The final node in a list" },
    { id: 37, term: "Sentinel", match: "Dummy node used to simplify list logic" },
    { id: 38, term: "Next", match: "Pointer to the succeeding node" },
    { id: 39, term: "Prev", match: "Pointer to the preceding node" },
    { id: 40, term: "LIFO", match: "Last In First Out" },
    { id: 41, term: "FIFO", match: "First In First Out" },
    { id: 42, term: "Stack", match: "Linear DS using push and pop" },
    { id: 43, term: "Queue", match: "Linear DS using enqueue and dequeue" },
    { id: 44, term: "Push", match: "Add an element to the top of a stack" },
    { id: 45, term: "Pop", match: "Remove an element from the top of a stack" },
    { id: 46, term: "Peek", match: "View the top element without removing it" },
    { id: 47, term: "Enqueue", match: "Add an element to the rear of a queue" },
    { id: 48, term: "Dequeue", match: "Remove an element from the front of a queue" },
    { id: 49, term: "Front", match: "Removal point in a standard queue" },
    { id: 50, term: "Rear", match: "Insertion point in a standard queue" },
    { id: 51, term: "Overflow", match: "Error when adding to a full structure" },
    { id: 52, term: "Underflow", match: "Error when removing from an empty structure" },
    { id: 53, term: "Priority Queue", match: "Queue where elements have associated urgency" },
    { id: 54, term: "Deque", match: "Double-ended queue structure" },
    { id: 55, term: "Circular Queue", match: "Queue that reuses space in a ring" },
    { id: 56, term: "Reversing", match: "Common linked list interview task" },
    { id: 57, term: "Middle Element", match: "Found using fast and slow pointers" },
    { id: 58, term: "Cycle Detection", match: "Floyd's Tortoise and Hare algorithm" },
    { id: 59, term: "Skip List", match: "Layered list allowing logarithmic search" },
    { id: 60, term: "Self-Organizing", match: "List that moves accessed items to head" },

    // --- Part 3: Trees & Hierarchies (61-100) ---
    { id: 61, term: "Root", match: "The top-most node of a tree" },
    { id: 62, term: "Leaf", match: "Node with no children" },
    { id: 63, term: "Parent", match: "Node that has edges to child nodes" },
    { id: 64, term: "Child", match: "Node descended from another node" },
    { id: 65, term: "Sibling", match: "Nodes that share the same parent" },
    { id: 66, term: "Ancestor", match: "Node on the path from root to target" },
    { id: 67, term: "Descendant", match: "Nodes reachable from a parent node" },
    { id: 68, term: "Subtree", match: "A tree formed by a node and its descendants" },
    { id: 69, term: "Binary Tree", match: "Each node has at most two children" },
    { id: 70, term: "BST", match: "Binary Search Tree" },
    { id: 71, term: "In-order", match: "LNR traversal: gives sorted BST values" },
    { id: 72, term: "Pre-order", match: "NLR traversal: visits root first" },
    { id: 73, term: "Post-order", match: "LRN traversal: visits root last" },
    { id: 74, term: "Level-order", match: "Breadth-first tree traversal" },
    { id: 75, term: "Height", match: "Longest path from node to a leaf" },
    { id: 76, term: "Depth", match: "Path length from root to a node" },
    { id: 77, term: "Balanced Tree", match: "Height difference between branches is minimal" },
    { id: 78, term: "AVL Tree", match: "Strictly balanced binary search tree" },
    { id: 79, term: "Red-Black Tree", match: "Self-balancing tree using color coding" },
    { id: 80, term: "Rotation", match: "Operation to rebalance a tree's height" },
    { id: 81, term: "B-Tree", match: "Self-balancing tree optimized for storage systems" },
    { id: 82, term: "Trie", match: "Tree used for fast prefix lookups" },
    { id: 83, term: "Segment Tree", match: "Tree used for range query problems" },
    { id: 84, term: "Fenwick Tree", match: "Also known as Binary Indexed Tree" },
    { id: 85, term: "Heap", match: "Complete tree following a min/max property" },
    { id: 86, term: "Min-Heap", match: "Root holds the smallest element" },
    { id: 87, term: "Max-Heap", match: "Root holds the largest element" },
    { id: 88, term: "Heapify", match: "Process of creating a heap from an array" },
    { id: 89, term: "Complete Tree", match: "All levels filled except possibly the last" },
    { id: 90, term: "Full Tree", match: "Every node has 0 or 2 children" },
    { id: 91, term: "Perfect Tree", match: "All interior nodes have two children and leaves are at same level" },
    { id: 92, term: "Skewed Tree", match: "Tree where nodes only have one child" },
    { id: 93, term: "Degenerate Tree", match: "Tree that performs like a linked list" },
    { id: 94, term: "LCA", match: "Lowest Common Ancestor" },
    { id: 95, term: "Successor", match: "The next node in in-order traversal" },
    { id: 96, term: "Predecessor", match: "The previous node in in-order traversal" },
    { id: 97, "term": "Spanning Tree", "match": "Subgraph connecting all vertices without cycles" },
    { id: 98, "term": "MST", "match": "Minimum Spanning Tree" },
    { id: 99, "term": "Huffman Tree", "match": "Used for data compression algorithms" },
    { id: 100, "term": "Threaded Tree", "match": "Tree that stores null pointers as traversal links" },

    // --- Part 4: Graphs (101-140) ---
    { id: 101, term: "Graph", match: "Collection of vertices and edges" },
    { id: 102, term: "Vertex", match: "A node in a graph" },
    { id: 103, term: "Edge", match: "Connection between two vertices" },
    { id: 104, term: "Directed", match: "Edge implies a one-way direction" },
    { id: 105, term: "Undirected", match: "Edge implies a two-way connection" },
    { id: 106, term: "Weighted", match: "Edge has an associated cost or value" },
    { id: 107, term: "Adjacency Matrix", match: "2D array representing graph connections" },
    { id: 108, term: "Adjacency List", match: "Array of lists representing neighbors" },
    { id: 109, term: "Path", match: "Sequence of edges connecting nodes" },
    { id: 110, term: "Cycle", match: "Path starting and ending at same node" },
    { id: 111, term: "DAG", match: "Directed Acyclic Graph" },
    { id: 112, term: "Topological Sort", match: "Linear ordering of vertices in a DAG" },
    { id: 113, term: "BFS", match: "Breadth-First Search: level by level" },
    { id: 114, term: "DFS", match: "Depth-First Search: deep exploration" },
    { id: 115, term: "Connected", match: "Path exists between every pair of vertices" },
    { id: 116, term: "Isomorphic", match: "Graphs with same structure but different labels" },
    { id: 117, term: "Bipartite", match: "Vertices can be divided into two disjoint sets" },
    { id: 118, term: "Complete Graph", match: "Every pair of distinct vertices is connected" },
    { id: 119, term: "Dijkstra", match: "Shortest path algorithm for non-negative weights" },
    { id: 120, term: "Bellman-Ford", match: "Shortest path allowing negative weights" },
    { id: 121, term: "Floyd-Warshall", match: "All-pairs shortest path algorithm" },
    { id: 122, term: "Prim's", match: "Greedy algorithm for MST" },
    { id: 123, term: "Kruskal's", match: "Edge-based algorithm for MST" },
    { id: 124, term: "A*", match: "Heuristic search algorithm" },
    { id: 125, term: "Greedy", match: "Algorithm making locally optimal choices" },
    { id: 126, term: "Backtracking", match: "Incremental recursion with undo steps" },
    { id: 127, term: "Ford-Fulkerson", match: "Max flow algorithm" },
    { id: 128, term: "Max Flow", match: "Greatest amount of flow in a network" },
    { id: 129, term: "Cut", match: "Partition of vertices into two sets" },
    { id: 130, term: "Min Cut", match: "Smallest capacity cut to separate source/sink" },
    { id: 131, term: "Eulerian Path", match: "Visits every edge exactly once" },
    { id: 132, term: "Hamiltonian Path", match: "Visits every vertex exactly once" },
    { id: 133, term: "Clique", match: "Subset where all vertices are adjacent" },
    { id: 134, term: "Degree", match: "Number of edges connected to a vertex" },
    { id: 135, term: "Source", match: "Node with no incoming edges" },
    { id: 136, term: "Sink", match: "Node with no outgoing edges" },
    { id: 137, term: "Transpose", match: "Graph with all edge directions reversed" },
    { id: 138, term: "Strongly Connected", match: "Path exists between all pairs in both directions" },
    { id: 139, term: "Weakly Connected", match: "Connected if directions are ignored" },
    { id: 140, term: "Traveling Salesman", match: "Shortest possible route visiting each city" },

    // --- Part 5: Hashing & Sets (141-170) ---
    { id: 141, term: "Hash Function", match: "Maps data to a fixed-size index" },
    { id: 142, term: "Collision", match: "Two keys map to the same hash" },
    { id: 143, term: "Chaining", match: "Storing collisions in a list at the index" },
    { id: 144, term: "Open Addressing", match: "Finding another slot upon collision" },
    { id: 145, term: "Probing", match: "Searching for next open slot" },
    { id: 146, term: "Load Factor", match: "Ratio of elements to table size" },
    { id: 147, term: "Rehashing", match: "Resizing and re-mapping all entries" },
    { id: 148, term: "Set", match: "Collection of unique elements" },
    { id: 149, term: "Map", match: "Collection of key-value pairs" },
    { id: 150, term: "Rolling Hash", match: "Efficient hash update for sliding window" },
    { id: 151, term: "Bloom Filter", match: "Probabilistic set for existence test" },
    { id: 152, term: "Salt", match: "Random data added to hash input" },
    { id: 153, term: "Consistent Hashing", match: "Hashing for distributed systems" },
    { id: 154, term: "Perfect Hash", match: "Function with no collisions for fixed set" },
    { id: 155, term: "Cryptographic Hash", match: "One-way secure hash function" },
    { id: 156, term: "Bucket", match: "Slot in a hash table array" },
    { id: 157, term: "Key", match: "Unique identifier for data" },
    { id: 158, term: "Value", match: "Data associated with a key" },
    { id: 159, term: "Dictionary", match: "Python term for a hash map" },
    { id: 160, term: "HashSet", match: "Implementation of set using hashing" },
    { id: 161, term: "TreeSet", match: "Sorted set implementation" },
    { id: 162, term: "BitSet", match: "Compact array of bits" },
    { id: 163, term: "Disjoint Set", match: "Data structure for non-overlapping sets" },
    { id: 164, term: "Union", match: "Merging two sets" },
    { id: 165, term: "Find", match: "Identifying the set a creator belongs to" },
    { id: 166, term: "Path Compression", match: "Flattening the structure of disjoint sets" },
    { id: 167, term: "Rank", match: "Upper bound on tree height in disjoint sets" },
    { id: 168, term: "Memoization", match: "Caching results of function calls" },
    { id: 169, term: "Cache", match: "High-speed data storage layer" },
    { id: 170, term: "LRU", match: "Least Recently Used eviction policy" },

    // --- Part 6: Sorting & Searching (171-210) ---
    { id: 171, term: "Bubble Sort", match: "Swaps adjacent elements repeatedly" },
    { id: 172, term: "Selection Sort", match: "Selects smallest element and moves to front" },
    { id: 173, term: "Insertion Sort", match: "Builds sorted array one item at a time" },
    { id: 174, term: "Merge Sort", match: "Divide and conquer stable sort" },
    { id: 175, term: "Quick Sort", match: "Partitioning based on a pivot" },
    { id: 176, term: "Pivot", match: "Reference element in Quick Sort" },
    { id: 177, term: "Heap Sort", match: "Sorting using a binary heap" },
    { id: 178, term: "Radix Sort", match: "Non-comparative integer sort" },
    { id: 179, term: "Counting Sort", match: "Sort based on key frequency" },
    { id: 180, term: "Bucket Sort", match: "Distributes elements into buckets" },
    { id: 181, term: "Shell Sort", match: "Generalized insertion sort with gaps" },
    { id: 182, term: "Tim Sort", match: "Hybrid sort used in Python/Java" },
    { id: 183, term: "Binary Search", match: "O(log n) search on sorted data" },
    { id: 184, term: "Linear Search", match: "O(n) sequential check" },
    { id: 185, term: "Interpolation Search", match: "Estimates position based on values" },
    { id: 186, term: "Lower Bound", match: "First element >= value" },
    { id: 187, term: "Upper Bound", match: "First element > value" },
    { id: 188, term: "Selection", match: "Finding the k-th smallest element" },
    { id: 189, term: "Quick Select", match: "Selection algorithm using partitioning" },
    { id: 190, term: "Stability", match: "Preserving order of equal elements" },
    { id: 191, term: "Comparison Sort", match: "Sort based on comparing elements" },
    { id: 192, term: "Divide and Conquer", match: "Recursive break-down strategy" },
    { id: 193, term: "Internal Sort", match: "Sorting data entirely in RAM" },
    { id: 194, term: "External Sort", match: "Sorting data too large for RAM" },
    { id: 195, term: "Best Case", match: "Minimum possible steps" },
    { id: 196, term: "Worst Case", match: "Maximum possible steps" },
    { id: 197, term: "Average Case", match: "Expected steps for random input" },
    { id: 198, term: "Adaptive", match: "Faster on partially sorted data" },
    { id: 199, term: "Inversion", match: "Pair of elements out of order" },
    { id: 200, term: "Cycle Sort", match: "Minimizes number of memory writes" },
    { id: 201, term: "Pancake Sort", match: "Sorting by flipping prefix" },
    { id: 202, term: "Bogo Sort", match: "Randomly shuffling until sorted" },
    { id: 203, term: "Sleep Sort", match: "Waiting proportional to value" },
    { id: 204, term: "Ternary Search", match: "Split into three parts to find max/min" },
    { id: 205, term: "Exponential Search", match: "Finding range then binary search" },
    { id: 206, term: "Jump Search", match: "Fixed steps then linear search" },
    { id: 207, term: "Bisect", match: "Python module for binary search" },
    { id: 208, term: "Comparator", match: "Function defining sort order" },
    { id: 209, term: "Lexicographical", match: "Dictionary order" },
    { id: 210, term: "Monotonic", match: "Entirely non-increasing or non-decreasing" },

    // --- Part 7: DP & Bit Manipulation (211-250) ---
    { id: 211, term: "Dynamic Programming", match: "Breaking down complex problems" },
    { id: 212, term: "Tabulation", match: "Bottom-up DP approach" },
    { id: 213, term: "Knapsack", match: "Classic optimization problem" },
    { id: 214, term: "LCS", match: "Longest Common Subsequence" },
    { id: 215, term: "LIS", match: "Longest Increasing Subsequence" },
    { id: 216, term: "Edit Distance", match: "Operations to transform strings" },
    { id: 217, term: "Fibonacci", match: "Sequence where n = (n-1) + (n-2)" },
    { id: 218, term: "Bitwise AND", match: "1 if both bits are 1" },
    { id: 219, term: "Bitwise OR", match: "1 if at least one bit is 1" },
    { id: 220, term: "XOR", match: "1 if bits are different" },
    { id: 221, term: "NOT", match: "Inverts all bits" },
    { id: 222, term: "Left Shift", match: "Multiplication by powers of 2" },
    { id: 223, term: "Right Shift", match: "Division by powers of 2" },
    { id: 224, term: "Mask", match: "Bit pattern to select bits" },
    { id: 225, term: "MSB", match: "Most Significant Bit" },
    { id: 226, term: "LSB", match: "Least Significant Bit" },
    { id: 227, term: "Population Count", match: "Number of set bits" },
    { id: 228, term: "Endianness", match: "Byte order in memory" },
    { id: 229, term: "Big Endian", match: "MSB at lowest address" },
    { id: 230, term: "Little Endian", match: "LSB at lowest address" },
    { id: 231, term: "Two's Complement", match: "Representation of negative integers" },
    { id: 232, term: "Overflow", match: "Result exceeds storage bits" },
    { id: 233, term: "Floating Point", match: "Representation of real numbers" },
    { id: 234, term: "IEEE 754", match: "Standard for floating point arithmetic" },
    { id: 235, term: "Mantissa", match: "Significant digits of float" },
    { id: 236, term: "Exponent", match: "Power component of float" },
    { id: 237, term: "Precision", match: "Number of significant digits" },
    { id: 238, term: "Rounding", match: "Approximating to nearest value" },
    { id: 239, term: "Underflow", match: "Number too small to represent" },
    { id: 240, term: "NaN", match: "Not a Number" },

    // --- Part 8: OS & Networking (251-300) ---
    { id: 241, term: "Process", match: "Program in execution" },
    { id: 242, term: "Thread", match: "Lightweight process" },
    { id: 243, term: "Context Switch", match: "Saving/Restoring process state" },
    { id: 244, term: "Scheduler", match: "Manages process execution" },
    { id: 245, term: "Deadlock", match: "Processes waiting for each other" },
    { id: 246, term: "Semaphore", match: "Variable to control access" },
    { id: 247, term: "Mutex", match: "Mutual Exclusion object" },
    { id: 248, term: "Race Condition", match: "Outcome depends on timing" },
    { id: 249, term: "Paging", match: "Memory management scheme" },
    { id: 250, term: "Segmentation", match: "Divides memory into segments" },
    { id: 251, term: "Virtual Memory", match: "Simulated memory using disk" },
    { id: 252, term: "Thrashing", match: "Excessive paging reducing performance" },
    { id: 253, term: "Kernel", match: "Core of the operating system" },
    { id: 254, term: "User Mode", match: "Restricted access mode" },
    { id: 255, term: "Kernel Mode", match: "Unrestricted access mode" },
    { id: 256, term: "System Call", match: "Request for kernel service" },
    { id: 257, term: "Interrupt", match: "Signal to stop current execution" },
    { id: 258, term: "Bootloader", match: "Loads OS into memory" },
    { id: 259, term: "File System", match: "Method of storing files" },
    { id: 260, term: "Inode", match: "Data structure for file metadata" },
    { id: 261, term: "Protocol", match: "Rules for data exchange" },
    { id: 262, term: "IP Address", match: "Unique device identifier" },
    { id: 263, term: "Port", match: "Endpoint for communication" },
    { id: 264, term: "Socket", match: "Endpoint for sending/receiving data" },
    { id: 265, term: "TCP", match: "Reliable connection-oriented protocol" },
    { id: 266, term: "UDP", match: "Unreliable connectionless protocol" },
    { id: 267, term: "HTTP", match: "Hypertext Transfer Protocol" },
    { id: 268, term: "HTTPS", match: "Secure version of HTTP" },
    { id: 269, term: "DNS", match: "Translates names to IPs" },
    { id: 270, term: "Router", match: "Forwards packets between networks" },
    { id: 271, term: "Switch", match: "Connects devices in a network" },
    { id: 272, term: "Packet", match: "Unit of data in network" },
    { id: 273, term: "Latency", match: "Time delay in transmission" },
    { id: 274, term: "Bandwidth", match: "Maximum data transfer rate" },
    { id: 275, term: "Firewall", match: "Network security system" },
    { id: 276, term: "Proxy", match: "Intermediary server" },
    { id: 277, term: "VPN", match: "Virtual Private Network" },
    { id: 278, term: "Encryption", match: "Encoding data for security" },
    { id: 279, term: "Decryption", match: "Decoding secure data" },
    { id: 280, term: "Public Key", match: "Key for encryption" },
    { id: 281, term: "Private Key", match: "Key for decryption" },
    { id: 282, term: "Certificate", match: "Validates identity" },
    { id: 283, term: "Handshake", match: "Establishing connection" },
    { id: 284, term: "Server", match: "Computer providing services" },
    { id: 285, term: "Client", match: "Computer requesting services" },
    { id: 286, term: "API", match: "Application Programming Interface" },
    { id: 287, term: "REST", match: "Architectural style for APIs" },
    { id: 288, term: "JSON", match: "JavaScript Object Notation" },
    { id: 289, term: "XML", match: "Extensible Markup Language" },
    { id: 290, term: "Database", match: "Structured collection of data" },
    { id: 291, term: "SQL", match: "Language for relational DBs" },
    { id: 292, term: "NoSQL", match: "Non-relational database" },
    { id: 293, term: "ACID", match: "Atomicity, Consistency, Isolation, Durability" },
    { id: 294, term: "Transaction", match: "Sequence of operations" },
    { id: 295, term: "Index", match: "Speeds up data retrieval" },
    { id: 296, term: "Query", match: "Request for data" },
    { id: 297, term: "Schema", match: "Database structure definition" },
    { id: 298, term: "Normalization", match: "Organizing data to reduce redundancy" },
    { id: 299, term: "Replication", match: "Copying data for redundancy" },
    { id: 300, term: "Sharding", match: "Distributing data across machines" },

    // --- Part 9: Strings & RegEx (301-350) ---
    { id: 301, term: "Pattern Matching", match: "Finding a substring within a larger text" },
    { id: 302, term: "KMP Algorithm", match: "Linear time search using a failure function" },
    { id: 303, term: "Rabin-Karp", match: "Pattern matching using rolling hashes" },
    { id: 304, term: "Boyer-Moore", match: "Search algorithm that skips text segments" },
    { id: 305, term: "Suffix Tree", match: "Compressed trie of all suffixes of a string" },
    { id: 306, term: "Suffix Array", match: "Sorted array of all starting positions of suffixes" },
    { id: 307, term: "Longest Common Prefix", match: "Standard LCP array used with suffix arrays" },
    { id: 308, term: "Trie Node", match: "Stores a character and links to next characters" },
    { id: 309, term: "Aho-Corasick", match: "Dictionary-matching algorithm for multiple patterns" },
    { id: 310, term: "Z-Algorithm", match: "Finds all occurrences of pattern in linear time" },
    { id: 311, term: "Hamming Distance", match: "Number of positions where characters differ" },
    { id: 312, term: "Levenshtein Distance", match: "Minimum edits to transform string A to B" },
    { id: 313, term: "Anagram", match: "Strings with same characters in different order" },
    { id: 314, term: "Palindrome", match: "String that reads the same forwards and backwards" },
    { id: 315, term: "Manacher's Algorithm", match: "Finds longest palindromic substring in O(n)" },
    { id: 316, term: "Subsequence", match: "Derived string by deleting zero or more characters" },
    { id: 317, term: "Substring", match: "Contiguous sequence of characters in a string" },
    { id: 318, term: "Lexicographical", match: "Alphabetical or dictionary ordering" },
    { id: 319, term: "Concatenation", match: "Joining two strings end-to-end" },
    { id: 320, term: "Immutable String", match: "String that cannot be modified after creation" },
    { id: 321, term: "String Buffer", match: "Mutable string sequence for efficient editing" },
    { id: 322, term: "RegEx", match: "Regular Expression for pattern description" },
    { id: 323, term: "DFA", match: "Deterministic Finite Automaton" },
    { id: 324, term: "NFA", match: "Non-deterministic Finite Automaton" },
    { id: 325, term: "Wildcard", match: "Symbol representing one or more characters" },
    { id: 326, term: "Tokenization", match: "Breaking a string into meaningful units" },
    { id: 327, term: "Delimiters", match: "Characters used to separate data tokens" },
    { id: 328, term: "Parsing", match: "Analyzing a string of symbols for structure" },
    { id: 329, term: "Escape Character", match: "Invokes alternative interpretation of characters" },
    { id: 330, term: "ASCII", match: "7-bit character encoding standard" },
    { id: 331, term: "Unicode", match: "Universal character encoding (UTF-8/16)" },
    { id: 332, term: "Bitmasking", match: "Using bitwise ops to filter string properties" },
    { id: 333, term: "Burrows-Wheeler", match: "Transformation used in data compression" },
    { id: 334, term: "Run-Length Encoding", match: "Replacing repeating data with a single value and count" },
    { id: 335, term: "Huffman Coding", match: "Variable-length prefix coding for compression" },
    { id: 336, term: "Lempel-Ziv", match: "Dictionary-based compression algorithm family" },
    { id: 337, term: "Entropy", match: "Measure of randomness in a data string" },
    { id: 338, term: "Alphabet", match: "Finite set of symbols used in a string" },
    { id: 339, term: "Prefix", match: "Initial segment of a string" },
    { id: 340, term: "Suffix", match: "Final segment of a string" },
    { id: 341, term: "Proper Prefix", match: "Prefix that is not equal to the whole string" },
    { id: 342, term: "Border", match: "Substring that is both a prefix and a suffix" },
    { id: 343, term: "Rolling Hash", match: "Hash that can be updated by sliding window" },
    { id: 344, term: "Finite Automata", match: "Abstract machine used in string processing" },
    { id: 345, term: "Greedy Matching", match: "Matching the longest possible substring" },
    { id: 346, term: "Lazy Matching", match: "Matching the shortest possible substring" },
    { id: 347, term: "Case Sensitivity", match: "Distinguishing between upper and lower case" },
    { id: 348, term: "Null Terminator", match: "Special character '\\0' marking end of string" },
    { id: 349, term: "Standard Template Library", match: "C++ library containing string/vector tools" },
    { id: 350, term: "Wrapper Class", match: "Object containing a primitive string type" },

    // --- Part 10: Computational Geometry & Advanced Math (351-400) ---
    { id: 351, term: "Convex Hull", match: "Smallest convex polygon containing all points" },
    { id: 352, term: "Graham Scan", match: "Algorithm to find convex hull using angles" },
    { id: 353, term: "Jarvis March", match: "Gift wrapping algorithm for convex hulls" },
    { id: 354, term: "Voronoi Diagram", match: "Partitioning plane based on distance to points" },
    { id: 355, term: "Delaunay Triangulation", match: "Triangulation maximizing the minimum angle" },
    { id: 356, term: "Euclidean Distance", match: "Straight-line distance between two points" },
    { id: 357, term: "Manhattan Distance", match: "Distance via axis-parallel paths (L1 norm)" },
    { id: 358, term: "Chebyshev Distance", match: "Maximum difference along any coordinate axis" },
    { id: 359, term: "Dot Product", match: "Scalar product of two vectors" },
    { id: 360, term: "Cross Product", match: "Vector product used to find orientation" },
    { id: 361, term: "Collinear", match: "Points that lie on the same straight line" },
    { id: 362, term: "Coplanar", match: "Points that lie on the same plane" },
    { id: 363, term: "Bounding Box", match: "Smallest rectangle containing a set of objects" },
    { id: 364, term: "Quadtree", match: "Tree DS for partitioning 2D space" },
    { id: 365, term: "Octree", match: "Tree DS for partitioning 3D space" },
    { id: 366, term: "KD-Tree", match: "Space-partitioning tree for k-dimensional points" },
    { id: 367, term: "Line Sweep", match: "Algorithm technique moving a line across the plane" },
    { id: 368, term: "Intersection", match: "Set of points where two shapes meet" },
    { id: 369, term: "Polygon", match: "Closed plane figure with straight sides" },
    { id: 370, term: "Centroid", match: "Arithmetic mean position of all points" },
    { id: 371, term: "Orientation", match: "Clockwise or counter-clockwise arrangement" },
    { id: 372, term: "Closest Pair", match: "Finding two points with minimum distance" },
    { id: 373, term: "Precision Error", match: "Inaccuracy in floating-point calculations" },
    { id: 374, term: "Epsilon", match: "Small constant used for float comparisons" },
    { id: 375, term: "Vectorization", match: "Using SIMD instructions for math operations" },
    { id: 376, term: "Rasterization", match: "Converting vector graphics to pixels" },
    { id: 377, term: "Ray Tracing", match: "Simulating light paths for 3D rendering" },
    { id: 378, term: "Barycentric Coordinates", match: "Defining points relative to a triangle's vertices" },
    { id: 379, term: "Interpolation", match: "Estimating values between known data points" },
    { id: 380, term: "Extrapolation", match: "Estimating values outside known data range" },
    { id: 381, term: "Matrix Multiplication", match: "O(n^3) or O(n^2.8) using Strassen's" },
    { id: 382, term: "Determinant", match: "Scalar value representing matrix scaling factor" },
    { id: 383, term: "Eigenvalue", match: "Scalar associated with a linear transformation" },
    { id: 384, term: "FFT", match: "Fast Fourier Transform for signal processing" },
    { id: 385, term: "Modular Arithmetic", match: "System of arithmetic for integers in a range" },
    { id: 386, term: "Prime Factorization", match: "Breaking a number into its prime components" },
    { id: 387, term: "GCD", match: "Greatest Common Divisor (Euclidean Algorithm)" },
    { id: 388, term: "LCM", match: "Least Common Multiple" },
    { id: 389, term: "Sieve of Eratosthenes", match: "Finding all primes up to a limit" },
    { id: 390, term: "Permutation", match: "Arrangement of items where order matters" },
    { id: 391, term: "Combination", match: "Selection of items where order does not matter" },
    { id: 392, term: "Factorial", match: "Product of all integers up to n (n!)" },
    { id: 393, term: "Fibonacci Sequence", match: "Sum of two preceding numbers (0, 1, 1, 2...)" },
    { id: 394, term: "Pascal's Triangle", match: "Triangular array of binomial coefficients" },
    { id: 395, term: "Pigeonhole Principle", match: "If n items in m containers, n > m, one has two" },
    { id: 396, term: "Inclusion-Exclusion", match: "Counting elements in a union of sets" },
    { id: 397, term: "Expected Value", match: "Average outcome of a random process" },
    { id: 398, term: "Probability Density", match: "Function describing likelihood of values" },
    { id: 399, term: "Normal Distribution", match: "Bell curve distribution of data" },
    { id: 400, term: "Regression", match: "Modeling relationship between variables" },
];

/**
 * Deterministically generates a daily challenge set based on the date.
 * Features:
 * - Sequential Question ID (Day 1 -> ID 1)
 * - Sequential Puzzle Window (Day 1 -> Pairs 1-8)
 * - Wraps around after 400 days
 */
export const generateDailyChallengeLocal = (dateString: string) => {
    // 1. Calculate Day Index (0-based) from an epoch
    // We use a fixed epoch so every user sees the same question on the same date.
    const epoch = new Date('2024-01-01').getTime();
    const current = new Date(dateString).getTime();
    const diffTime = Math.abs(current - epoch);
    const dayIndex = Math.floor(diffTime / (1000 * 60 * 60 * 24)); // Total days passed

    // 2. Select Question (Day N maps to Question N % 400)
    // Puzzle Game is now the PRIMARY game.
    // Logic: Sliding Window of 4 pairs (as per request "one 4 questions asked")
    const windowSize = 4;
    // We want the window to move by 1 each day.
    // Day 0: 1-8
    // Day 1: 2-9
    const puzzlePairs = [];
    for (let i = 0; i < windowSize; i++) {
        const index = (dayIndex + i) % POOL_PUZZLES.length;
        puzzlePairs.push(POOL_PUZZLES[index]);
    }

    return {
        date: dateString,
        // Empty Mixed/Flashcards as user deleted the "Flip Game"
        mixed: [],
        flashcards: [],
        puzzle: puzzlePairs,
        debugger: [],
        mistakeFinder: []
    };
};
